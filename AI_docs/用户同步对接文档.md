



# **单点用户同步接口对接文档**

### 一、用户同步接口

​	用户同步数据是比较敏感的，传输中需要考虑安全性、性能和易用性。依据这三个特征采用非对称加密与对称加密结合方式，既能保存安全性，以能兼顾性能。该接口实现**全量同步**与**增量同步**;接口对接前需要联系BPM管理员进行**注册系统**，并提供注册信息：系统名称、系统内/网外访问地址，注册完成后向管理要取**appId** ，

#### **1. 对接前准备工作**：

​	准备注册信息：系统名称、系统内/网外访问地址

​	提交调用接口服务地址：总部需要添加白名单使用

​	配置环境变量：获取公钥，在本文档中获取即可

#### **2. 功能描述**

​	该接口提供航信办公系统用户同步功能，同步分为全量同步与增量同步；

同步策略：

1. 首次同步无论参数是全量或者增量均为全量
2. 无增量同步记录，根据上一次全量同步的 时间做为开始时间，以当前时间为结束时间查询增量数据，
3. 有增量同步记录，根据上一次增量同步的 时间做为开始时间，以当前时间为结束时间查询增量数据

用户信息描述

| 字段           | 类型   | 名称         | 说明                                     |
| -------------- | ------ | ------------ | ---------------------------------------- |
| id             | int    | 用户id       | 唯一标识                                 |
| logindid       | String | 登录账号     | 唯一标识  **注：删除的用户这个值是空的** |
| lastname       | String | 用户名称     |                                          |
| email          | String | 用户邮箱     |                                          |
| certificatenum | String | 用户身份证号 | 唯一标识                                 |
| departmentid   | String | 部门id       |                                          |
| departmentname | String | 部门名称     |                                          |
| departmentcode | String | 部门编码     |                                          |
| subcompanyid1  | String | 公司id       |                                          |
| subcompanyname | String | 公司名称     |                                          |
| subcompanycode | String | 公司编码     |                                          |
| accounttype    | String | 账号类型     | 0 主账号 1次账号                         |
| status         | String | 状态         | 0：试用1：正式2：临时3：试用延期         |

#### **3. 请求地址**

测试环境：http://10.121.1.95:8088/c-interface/user-sync/user-info

生产环境：http://10.121.1.95:8888/c-interface/user-sync/user-info（暂未发布）

#### **4. HTTP请求方法（Method）**

​	HTTP POST

#### **5. 请求参数（Request）**

- 请求头（Request Headers）：

| header名     | 值               |
| ------------ | ---------------- |
| Content-Type | application/json |

- 请求体（Request Body）

Content-Type: application/json

| 参数名称   | 参数说明   | 是否必须 | 数据类型                         | 说明                         |
| :--------- | :--------- | :------- | :------------------------------- | :--------------------------- |
| syncUserPo | syncUserPo | true     | 用户同步参数对象用户同步参数对象 |                              |
| --aesKey   | aesKey     | true     | String                           | 数据加密密钥，公钥加密后数据 |
| --appId    | appId      | true     | String                           | 航信办公生成唯一标识         |
| --syncMode | syncMode   | true     | String                           | 同步标识，全量：FS  增量：IS |

json示例：

```json
{
	"aesKey": "V2svazYoo210vVvLzaZqtpNN/ST0Oq24zWjQxoT0AnEnKgzJaCZ+ofy1klegKvXHw+OE+Zwnkt9iaGM6X7RMTgmRA3c2TJ1thY9Om8y3QGzt+fDoy3talfQQxj1d6a9k5iUy2hIqK1hBYt8D4iAqp8eKIumtv14/dqVjYnaIyK1xlaN2sjfUEMQPksm1Fb9KPVurF9LUKfggsOu+zxaitJXoV1xii0/i1VKlVAeXSCLyeHbLCAbi1djYmlmSTaLEtfhL+Wslb/s4z3w+aqXfJl0ODV5Fz61h5z9/39GHTVI8ZXPf5/LK55F0X5vO8X9llI1MMXZ/03IAmBrSwpYXzg==",
	"appId": "YxCZYCS",
	"syncMode": "FS"
}
```

* 响应示例

成功响应

```json
{
  "code": 0,
  "message": "SUCCESS",
  "data": {
    "encryptedData": "gpVO1XM9sU6c+XQiFNoWgLzu26WaNIi+8RYY62h5rmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnxof6h1Jzk8bwgqcLXADphBTnBfihe9XN9r2SkZUIXzxLdzifZ484H0OSNPy6BkWbZQCnc7Tq52xt/5lFYJ+g05A2vAVt6zIHu6Ecu3ReX3NdEjpYULTotIoLKirmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnx/erzzCEbwpPf9zPNpPoARF3uP2z4YRrMMkcCBXVQVI0i2TaJq e+hOziQ==",
    "signature": "BeLJpY9BQQmkPG6O35OoGbor1CylCP7rmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnxxmIij03PepoYd8GTwfYSoUB6Tdw==",
    "summary": "b5eef4b6ac700ce66018b9e0399cf78b"
  }
}
```

失败响应

```json
{
  "code": 1,
  "message": "ERROR",
  "data": "错误信息描述"
}
```

* 响应参数说明

| 接口返回码 | 接口返回描述 |
| :--------- | :----------- |
| 0          | 成功         |
| 1          | 失败         |

* 响应数据参数说明

| 接口返回数据字段 | 接口返回字段描述 |
| :--------------- | :--------------- |
| signature        | 摘要信息签名     |
| summary          | 摘要信息         |
| encryptedData    | 加密数据         |

#### 6.公钥

**注：正式公钥信息，**

```text
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsU2iTqyhUgb/G/4UD9BES4zuNoAE3nNtaKLUKXkCZSyrwmDcf4mbOru8McFY7MDuvzpjnocVQI+qNvtBvDpjbL45029kwIWxpGPV0ahkT8ybc0ZeUse6ckcSIuJB8374QA7rWkuCSik//qN5Yn+r++ZN/p+UlGLozCQLAkcvYILqECPBadpJf9Dq3oqrYZnhDyyNswegvHXU3k3bY9jb7YCXpDaGbOFxjm1/0t97dzzdcXCQnNR1Uoe//dBQvJPlgruNh8tLUWAz+MBeeYA5VkhPnDOOGClcPa2tRXyolUF8n9P0XRmVdn9TWLoCB1J9ZW0cH+yqdmL20fnryNmPDwIDAQAB
```

 对接调试时可重新生成一对。

#### 7.客户端调用实例

​	**1) 生成AESKEY密钥并使用公钥加密**

```java
// 获取公钥对象
String pkey = System.getenv("API_PKEY");  // 公钥
PublicKey publicKey = EncryptionUtil.base64ToPublicKey(pkey);
// 加密对象
SecretKey clientAesKey = EncryptionUtil.generateAESKey();
// 本质是生成16/24/32字节的随机字节数组（对应AES-128/192/256）
byte[] clientAesKeyBytes = clientAesKey.getEncoded();
// 加密 AES
String encryptedAesKey = EncryptionUtil.encryptWithRSA(clientAesKeyBytes, publicKey);
```

​	**2)封装请求参数**

```json
{
	"aesKey": "V2svazYoo210vVvLzaZqtpNN/ST0Oq24zWjQxoT0AnEnKgzJaCZ+ofy1klegKvXHw+OE+Zwnkt9iaGM6X7RMTgmRA3c2TJ1thY9Om8y3QGzt+fDoy3talfQQxj1d6a9k5iUy2hIqK1hBYt8D4iAqp8eKIumtv14/dqVjYnaIyK1xlaN2sjfUEMQPksm1Fb9KPVurF9LUKfggsOu+zxaitJXoV1xii0/i1VKlVAeXSCLyeHbLCAbi1djYmlmSTaLEtfhL+Wslb/s4z3w+aqXfJl0ODV5Fz61h5z9/39GHTVI8ZXPf5/LK55F0X5vO8X9llI1MMXZ/03IAmBrSwpYXzg==",
	"appId": "YxCZYCS",
	"syncMode": "FS"
}
```

​	**3)接收服务端数据如下样例**

```json

{
  "code": 0,
  "message": "SUCCESS",
  "data": {
    "encryptedData": "gpVO1XM9sU6c+XQiFNoWgLzu26WaNIi+8RYY62h5rmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnxof6h1Jzk8bwgqcLXADphBTnBfihe9XN9r2SkZUIXzxLdzifZ484H0OSNPy6BkWbZQCnc7Tq52xt/5lFYJ+g05A2vAVt6zIHu6Ecu3ReX3NdEjpYULTotIoLKirmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnx/erzzCEbwpPf9zPNpPoARF3uP2z4YRrMMkcCBXVQVI0i2TaJq e+hOziQ==",
    "signature": "BeLJpY9BQQmkPG6O35OoGbor1CylCP7rmXjZ6vGtoZXlvPLq6kecCFZ2WEE9F3rAtmMi2k5fyEkNZwpW/5kAhiAYxBcmi3TzWErw9kmi1hrWDcNtTUeLG6xsaZw+C3imZSkp0BkUP2UupGYc/iAQYq5HhjewOJonFcTroRfA8LK/62cDQSr2y/+QcFGDj50lg4dYZuQUEHL7JxfKNfXcTsQVsRW91A1yHNHP8WbLR4FmGSZ5C3hzYwhgOzev+9XZWJOveQHmnL+yhokC0wIuYd4OtiOkrO8B68uy4T2KEPZeJK30BxSU+u8thnxxmIij03PepoYd8GTwfYSoUB6Tdw==",
    "summary": "b5eef4b6ac700ce66018b9e0399cf78b"
  }
}
```

​	**4）解析数据**

```java
// 加密数据生成摘要信息
String summaryNew = MD5Utils.MD5(encryptData);
// 校验与接收到的摘要信息是否一致
if(!summaryNew.equals(summary)) return;
// 验签  
boolean vr = EncryptionUtil.verifyWithPublicKey(summaryNew.getBytes(), signature, publicKey);
if(!vr){
    System.out.println(" 验签失败");
    return;
}
// 数据解密，解密→解压缩→反序列化(json)
String userInfoJson = SyncDataProcessor.decryptAndRestoreToJson(encryptedData, clientAesKey);
// 数据解密，解密→解压缩→反序列化(对象)
// List<SyncData> syncData = SyncDataProcessor.decryptAndRestore(encryptedData, clientAesKey);
```

#### 8.工具类

**EncryptionUtil.java**

```java
package com.yjl.cloud.server.modules.ssosync.utils;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * 加密工具类，提供RSA和AES加密解密功能
 */
public class EncryptionUtil {
    //
    /**
     * AES加密算法配置
     * 算法：RSA
     * 模式：ECB（电子密码本模式）
     * 填充方式：PKCS5Padding
     */
    public static final String AES_ALGORITHM = "AES/ECB/PKCS5Padding";
    public static final int AES_KEY_SIZE = 256;

    /**
     * RSA加密算法配置
     * 算法：RSA
     * 模式：ECB（电子密码本模式）
     * 填充方式：PKCS1Padding
     */
    public static final String RSA_CIPHER_ALGORITHM = "RSA/ECB/PKCS1Padding";  // 加密/解密：使用完整的算法描述 "RSA/ECB/PKCS1Padding" 来获取 Cipher 实例
    public static final int RSA_KEY_SIZE = 2048;

    public static final String RSA_ALGORITHM = "RSA";   // 密钥生成：使用简单的算法名称 "RSA"

    // 签名算法（SHA256withRSA：SHA256摘要+RSA签名）
    public static final String SIGNATURE_ALGORITHM = "SHA256withRSA";

    /**
     * 生成AES密钥
     */
    public static SecretKey generateAESKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(AES_KEY_SIZE);
        return keyGenerator.generateKey();
    }
    /**
     * 用RSA公钥加密数据
     */
    public static String encryptWithRSA(byte[] data, PublicKey publicKey) throws Exception {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("加密数据不能为空");
        }
        if (publicKey == null) {
            throw new IllegalArgumentException("RSA公钥不能为空");
        }

        Cipher cipher = Cipher.getInstance(RSA_CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] encryptedData = cipher.doFinal(data);
        return Base64.getEncoder().encodeToString(encryptedData);
    }
    /**
     * 将Base64编码的公钥字符串转换为PublicKey对象
     */
    public static PublicKey base64ToPublicKey(String base64PublicKey) throws Exception {
        if (base64PublicKey == null || base64PublicKey.isEmpty()) {
            throw new IllegalArgumentException("公钥字符串不能为空");
        }

        byte[] keyBytes = Base64.getDecoder().decode(base64PublicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        return keyFactory.generatePublic(keySpec);
    }
    /**
     * 客户端用公钥验证签名（验证服务端发送的数据合法性）
     * @param data 原始数据字节数组（与签名时的data一致）
     * @param sign 服务端发送的签名字符串（Base64编码）
     * @param publicKey 服务端RSA公钥（客户端持有）
     * @return 验证通过返回true，否则返回false
     */
    public static boolean verifyWithPublicKey(byte[] data, String sign, PublicKey publicKey) throws Exception {
        validateParams(data, sign, publicKey);

        byte[] signBytes = Base64.getDecoder().decode(sign);
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
        signature.initVerify(publicKey);
        signature.update(data);
        return signature.verify(signBytes); // 验证签名是否匹配
    }
    // 参数校验重载方法
    private static void validateParams(byte[] data, String sign, Object key) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("验证数据不能为空");
        }
        if (sign == null || sign.isEmpty()) {
            throw new IllegalArgumentException("签名不能为空");
        }
        if (key == null) {
            throw new IllegalArgumentException("密钥不能为空");
        }
    }
}
```

**SyncDataProcessor.java**

```java
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.yjl.cloud.server.modules.ssosync.entity.SyncData;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.List;

/**
 * SyncData列表处理工具类，整合序列化、压缩和加密功能
 * @author LY
 * @since 2025-09-18
 */
public class SyncDataProcessor {
    // 复用ObjectMapper实例提高性能
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
      /**
     * 还原SyncData列表：解密→解压缩→反序列化
     */
    public static List<SyncData> decryptAndRestore(String encryptedData, SecretKey aesKey) throws Exception {
        if (encryptedData == null || encryptedData.isEmpty()) {
            throw new IllegalArgumentException("加密数据不能为空");
        }

        // 1. 解密数据
        byte[] compressedData = EncryptionUtil.decryptWithAESBytes(encryptedData, aesKey);

        // 2. 解压缩
        byte[] jsonBytes = CompressionUtil.decompress(compressedData);

        // 3. 反序列化为对象列表
        return objectMapper.readValue(jsonBytes, new TypeReference<List<SyncData>>() {});
    }

    /**
     * 还原SyncData列表的JSON字符串：解密→解压缩→转为JSON字符串
     *
     * @param encryptedData 加密后的字符串
     * @param aesKey        AES密钥
     * @return 原始的SyncData列表JSON字符串
     * @throws Exception 解密、解压缩或JSON转换异常
     */
    public static String decryptAndRestoreToJson(String encryptedData, SecretKey aesKey) throws Exception {
        if (encryptedData == null || encryptedData.isEmpty()) {
            throw new IllegalArgumentException("加密数据不能为空");
        }

        // 1. 解密数据（得到压缩后的字节数组）
        byte[] compressedData = EncryptionUtil.decryptWithAESBytes(encryptedData, aesKey);

        // 2. 解压缩（得到原始的JSON字节数组）
        byte[] jsonBytes = CompressionUtil.decompress(compressedData);

        // 3. 将JSON字节数组转换为字符串（使用UTF-8编码，避免中文乱码）
        return new String(jsonBytes, StandardCharsets.UTF_8);
    }

}
    
```

**MD5Utils.java**

```java
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * MD5加密/验证工具类
 * @author LY
 * @since 2025-09-18
 */
public class MD5Utils {
    static final char hexDigits[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    static final char hexDigitsLower[] = { '0', '1', '2', '3', '4', '5', '6', '7','8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    /**
     *   对字符串 MD5 无盐值加密
     *
     * @param plainText
     * 		传入要加密的字符串
     * @return
     *  	MD5加密后生成32位(小写字母+数字)字符串
     */
    public static String MD5Lower(String plainText) {
        try {
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest md = MessageDigest.getInstance("MD5");

            // 使用指定的字节更新摘要
            md.update(plainText.getBytes());

            // digest()最后确定返回md5 hash值，返回值为8位字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符
            // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值。1 固定值
            return new BigInteger(1,  md.digest()).toString(16);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    } 
    /**
     *  对字符串 MD5 加密
     *
     * @param plainText
     * 		传入要加密的字符串
     * @return
     * 		MD5加密后生成32位(大写字母+数字)字符串
     */
    public static String MD5Upper(String plainText) {
        try {
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest md = MessageDigest.getInstance("MD5");

            // 使用指定的字节更新摘要
            md.update(plainText.getBytes());

            // 获得密文
            byte[] mdResult = md.digest();
            // 把密文转换成十六进制的字符串形式
            int j = mdResult.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = mdResult[i];
                str[k++] = hexDigits[byte0 >>> 4 & 0xf];// 取字节中高 4 位的数字转换, >>> 为逻辑右移，将符号位一起右移
                str[k++] = hexDigits[byte0 & 0xf]; // 取字节中低 4 位的数字转换
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     *   对字符串 MD5 加盐值加密
     *
     * @param plainText
     * 		传入要加密的字符串
     * @param saltValue
     * 		传入要加的盐值
     * @return
     *  	MD5加密后生成32位(小写字母+数字)字符串
     */
    public static String MD5Lower(String plainText, String saltValue) {
        try {
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest md = MessageDigest.getInstance("MD5");

            // 使用指定的字节更新摘要
            md.update(plainText.getBytes());
            md.update(saltValue.getBytes());

            // digest()最后确定返回md5 hash值，返回值为8位字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符
            // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值。1 固定值
            return new BigInteger(1,  md.digest()).toString(16);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     *   对字符串 MD5 加盐值加密
     *
     * @param plainText
     * 		传入要加密的字符串
     * @param saltValue
     * 		传入要加的盐值
     * @return
     *  	MD5加密后生成32位(大写字母+数字)字符串
     */
    public static String MD5Upper(String plainText, String saltValue) {
        try {
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest md = MessageDigest.getInstance("MD5");

            // 使用指定的字节更新摘要
            md.update(plainText.getBytes());
            md.update(saltValue.getBytes());

            // 获得密文
            byte[] mdResult = md.digest();
            // 把密文转换成十六进制的字符串形式
            int j = mdResult.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = mdResult[i];
                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
                str[k++] = hexDigits[byte0 & 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    /**
     *  MD5加密后生成32位(小写字母+数字)字符串
     *    同 MD5Lower() 一样
     */
    public final static String MD5(String plainText) {
        try {
            MessageDigest mdTemp = MessageDigest.getInstance("MD5");

            mdTemp.update(plainText.getBytes("UTF-8"));

            byte[] md = mdTemp.digest();
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigitsLower[byte0 >>> 4 & 0xf];
                str[k++] = hexDigitsLower[byte0 & 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            return null;
        }
    }
    /**
     *  校验MD5码
     *
     * @param text
     *      	要校验的字符串
     * @param md5
     *            md5值
     * @return 校验结果
     */
    public static boolean valid(String text, String md5) {
        return md5.equals(MD5(text)) || md5.equals(MD5(text).toUpperCase());
    }
}
```

**SyncData.java**

```java
// 数据对象 
import lombok.Data;

import java.io.Serializable;

@Data
public class SyncData implements Serializable {
    // 用户id
    private int id;
    // 登录账号   注：删除的用户这个值是空的 可以用这个值来判断是否是不是被删除了
    private String logindid;
    // 用户名称
    private String lastname;
    // 用户邮箱
    private String email;
    // 用户身份证号
    private String  certificatenum;
    // 部门id
    private String departmentid;
    // 部门名称
    private String departmentname;
    // 部门编码
    private String departmentcode;
    // 公司id
    private String subcompanyid1;
    // 公司名称
    private String subcompanyname;
    // 公司编码
    private String subcompanycode;
    // 账号类型  0 主账号 1次账号
    private String  accounttype;
    // 状态   数据状态:0：试用1：正式2：临时3：试用延期
    private String status;

}

```



### 二、在线接口文档

http://10.121.1.95:8088/c-interface/doc.html   (正式环境【需要时临时开户】)

